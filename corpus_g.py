# generated by chatGPT
import re
import nltk
from collections import Counter, defaultdict

nltk.download("punkt")
nltk.download("averaged_perceptron_tagger")
nltk.download('averaged_perceptron_tagger_eng')
nltk.download('maxent_ne_chunker_tab')
nltk.download('maxent_ne_chunker')
nltk.download('words')

def add_wikipedia_article(topic):
    import wikipedia
    wikipedia.set_lang("en")
    try:
        article = wikipedia.page(topic, auto_suggest=False)
        return article.content
    except Exception as e:
        print(f"Failed to fetch article: {e}")
        return ""

text = ""
text += add_wikipedia_article("Banana (fruit)")
if not text.strip():
    print("No text fetched from Wikipedia. Check topic name or internet connection.")

# color
def colorize(text, color="red"):
    color_codes = {
        "red": "\033[91m",
        "green": "\033[92m",
        "yellow": "\033[93m",
        "blue": "\033[94m",
        "magenta": "\033[95m",
        "cyan": "\033[96m",
        "end": "\033[0m",
    }
    return f"{color_codes.get(color, '')}{text}{color_codes['end']}"


# SORTED BY OCCURRENCE ORDER
def kwic_sorted_by_occurrence(text, search_words, window, color):
    tokens = re.findall(r"\b\w+\b", text)
    target_tokens = search_words.split()
    n = len(target_tokens)

    kwic_list = []

    for i in range(len(tokens) - n + 1):
        if tokens[i : i + n] == target_tokens:
            start = max(0, i - window)
            end = min(len(tokens), i + n + window)
            left = tokens[start:i]
            match = colorize(" ".join(tokens[i : i + n]), color)
            right = tokens[i + n : end]
            kwic_string = " ".join(left + [match] + right)
            kwic_list.append(kwic_string)

    return kwic_list

# NEXT TOKEN FREQUENCY
def kwic_sorted_by_next_token(text, search_words, window, color):
    tokens = re.findall(r"\b\w+\b", text)
    target_tokens = search_words.split()
    n = len(target_tokens)

    next_token_counter = Counter()
    kwic_by_next_token = defaultdict(list)

    for i in range(len(tokens) - n + 1):
        if tokens[i : i + n] == target_tokens:
            start = max(0, i - window)
            end = min(len(tokens), i + n + window)
            left = tokens[start:i]
            match = colorize(" ".join(tokens[i : i + n]), color)
            right = tokens[i + n : end]
            kwic_string = " ".join(left + [match] + right)

            next_word = tokens[i + n] if (i + n) < len(tokens) else ""
            next_token_counter[next_word] += 1
            kwic_by_next_token[next_word].append(kwic_string)

    sorted_kwic = []
    for word, _ in next_token_counter.most_common():
        sorted_kwic.extend(kwic_by_next_token[word])

    return sorted_kwic, next_token_counter

# POS tags
def kwic_pos_filter(text, search_words, window, color):
    tokens = nltk.word_tokenize(text)
    pos_tags = nltk.pos_tag(tokens)
    target_tokens = search_words.split()
    n = len(target_tokens)

    verbs = []
    nouns = []
    adjectives = []

    for i in range(len(tokens) - n + 1):
        if tokens[i:i + n] == target_tokens:
            next_index = i + n
            if next_index < len(pos_tags):
                word, tag = pos_tags[next_index]

                if tag.startswith("VB"):      # 動詞
                    result_list = verbs
                elif tag.startswith("NN"):    # 名詞
                    result_list = nouns
                elif tag.startswith("JJ"):    # 形容詞
                    result_list = adjectives
                else:
                    continue  # 対象品詞でなければスキップ

                start = max(0, i - window)
                end = min(len(tokens), i + n + window + 1)
                left = tokens[start:i]
                match = colorize(" ".join(tokens[i:i + n]), color)
                right = tokens[i + n:end]
                kwic_string = " ".join(left + [match] + right)
                result_list.append("... " + kwic_string + " ...")

    return verbs, nouns, adjectives

def main():
    while True:
        
        print("\n=== MENU ===")
        print("1: Sort by occurrence order")
        print("2: Sort in order of frequency of occurrence")
        print("3: POS tags")
        print("4: exit")
        choice = input("Please choose your search type from 3 options(1〜4): ")

        if choice == "1":
            search_words = input("\nPlease enter a search term (e.g. banana): ")
            window = int(
                input("Please enter the window size (number of words to display before and after) (e.g. 2): "))
            color = input("Please enter a color for the search term (e.g. red, green, yellow, blue, magenta, cyan, end): ")

            results = kwic_sorted_by_occurrence(text, search_words=search_words, window=window, color=color)

            print("\n[KWIC RESULTS SORTED BY OCCURRENCE ORDER]\n")
            for r in results:
               print("... " + r + " ...")


        if choice == "2":
            search_words = input("\nPlease enter a search term (e.g. banana): ")
            window = int(
                input("Please enter the window size (number of words to display before and after) (e.g. 2): "))
            color = input("Please enter a color for the search term (e.g. red, green, yellow, blue, magenta, cyan, end): ")

            results, freq = kwic_sorted_by_next_token(text, search_words=search_words, window=window, color=color)

            print("\n[KWIC RESULTS SORTED BY NEXT TOKEN FREQUENCY]\n")
            for r in results:
                print("... " + r + " ...")

        elif choice == "3":
            search_words = input("\nPlease enter a search term (e.g. banana): ")
            window = int(input("Please enter the window size (e.g. 2): "))
            color = input("Please enter a color for the search term (e.g. red, green, yellow, blue, magenta, cyan, end): ")

            verbs, nouns, adjectives = kwic_pos_filter(text, search_words, window, color)

            print("\n<VERBS>")
            for v in verbs:
                print(v)

            print("\n<NOUNS>")
            for n in nouns:
                print(n)

            print("\n<ADJECTIVES>")
            for adj in adjectives:
                print(adj)



        elif choice == "4":
            print("exit program")
            break

        else:
            print("Erorr: Please enter a number between 1 and 4.")


if __name__ == "__main__":
    main()
